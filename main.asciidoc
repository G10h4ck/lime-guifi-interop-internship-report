Interoperability between Libre-Mesh and Guifi.net
=================================================
:author: Gioacchino Mazzurco
:email: gio@eigenlab·org
:lang: en

:MdHd: Modelo Híbrido
:SpNd: supernodo
:Nd: nodo


The biggest community network of the world is Guifi.net ^<<ref:5, [5]>>^ and it spreads across Catalonia and beyond. IP routing on a such big community network is not a trivial task, in addition to the big size, the decentralized nature of our network encourage choice, so usually different parts of our networks uses different routing protocols. +
In order to make those routing protocols interoperate is now mostly a manual job, various groups have developed several OpenWrt based solutions to ease networking equipment configuration, but seamless protocol interoperability is an open problem, moreover we work mostly with low cost embedded device, so little performance footprint is always a requirement. +
The scope of this work is to investigate mainly used routing protocols in particular BGP, BMX6 and BATMAN-adv, to study past interoperability experiments and to extend Libre-Mesh and possibly implementing seamless interoperability between it and Guifi.net. +
The new feature must be usable and stable so at the end of the project we can deploy it in our production setups such as Barcelona Botanical Garden, our offices in Aureasocial and others clients. +
Testing of the new features in real environment and protocols parameters adjusting for the optimal functioning is part of this work too.


== Guifi.net
Our networks uses different routing protocols such as BGP, OSPF, OLSR, Bmx6, BATMAN-adv, Babel and more.
Over time lot of Guifi.net nodes have been build sticking to the older but well known solution named _<<modelohibrido, {MdHd}>>_.
This solution imply lot of manual work and a central provisioning server that know all details about the Guifi.net network, de facto limiting the resilience,  the scalability and the growth of Guifi.net. To overcome _{MdHd}_ limitation lot of efforts developing new solutions have existed most of them based on mesh technology but none of them, mainly because of resource lack and consequent missing long term support, have been widely adopted causing even more fragmentation and making more difficult interoperability. Aside from this context <<libre-mesh, Libre-Mesh>> has been bred independently but with the joint forces of multiples community networks seems a long term viable solution and offer already lot of advantages in respect to the other explored paths.

[[modelohibrido]]
=== {MdHd}
As of _{MdHd}_ community network nodes can belong to two categories: _{SpNd}s_ and _{Nd}s_, in this model _{Nd}s_ are not really nodes of the network as they do not do routing for other nodes of Guifi.net and just attach to a _{SpNd}s_, while _{SpNd}s_ do route ^<<ref:4, [4]>>^. In _{SpNd}s_ usually a _Mikrotik routerboard_ is used as router while externals WiFi AP are configured as plain WDS bridge ^<<ref:1, [1]>>^, if two _{SpNd}s_ are connected by a WiFi link the router of each node see the router of the other node as if it was directly connected with an Ethernet cable. On top of the routers of each node BGP routing protocol is running, on each node connected BGP peering have to be established, each _{SpNd}_ has his own unique private ASN assigned by the Guifi.net Drupal based network map, in this setup each _{SpNd}_ of Guifi.net act as an AS with typical eBGP information exchange mode. +
While BPG seems the more appropriate routing protocol for a neutral internet exchange point, wireless community networks have completely different needs that BGP cannot satisfy such as chosing WiFi path with more bandwidth availabe or automatic link establishment. _{MdHd}_ has helped Guifi.net to grow but over time new tecnology better suited for wireless community have emerged exposing many limitations of this model.

=== qMp
QMP ^<<ref:2, [2]>>^ do facilitate the creation of roaming enabled mesh networks, it is based on OpenWrt and BMX6, qMp already supports configuration provisioning by guifi.net map _unsolclick_ ^<<ref:0, [citation needed]>>^ for mesh parameters adjusting but it leave the interoperability with <<modelohibrido, Ibrid Model>> mostly to manual static configuration done by the user ^<<ref:3, [3]>>^ or in rare cases to manually configured Quagga-BMX6 module that is unreliable, resource intensive and requires manual configuration. Moreover qMp is designed around BMX6, in a way that to add support for another routing protocol would imply a big refactoring in qMp code.

[[libre-mesh]]
== Libre-Mesh
Libre-Mesh is an initiative undertaken by community networks members of several continents that collaborate towards a common goal: to develop a set of tools that facilitate the deployment of Free Networks for any community in the world. +
Main tool is LiMe meta-firmware: based on OpenWrt, eases the creation of community networks, and enables existing communities to add roaming enabled network clouds to their networks. +
To accomplish his goal LiMe meta-firmware have an highly modular design and implementation, the core of LiMe meta-firmware is the lime-system package.

=== Software Architecture
LiMe meta-firmware is structured as a set of OpenWrt packages, it provides a command line tool `lime-config` that when invoked simply delegate the work of updating the configurations to installed LiMe modules by calling their `clean()` and `configure()` methods, LiMe minimal installation already ships necessary modules but the architecture is meant to be extensible so more modules can be added if needed. LiMe modules are often modular themselves, an UML scheme may help the comprehension of LiMe architecture as a whole:

image::images/libre-mesh_software_architecture.png[align="center"]

Highlighted in green the parts modified and in blue the brand-new parts developed from scratch in the scope of the internship.


==== Hardware Detection
Hardware detection module is in charge of detecting hardware components of the router and if some of them need a special configuration in order to work according to lime needs generate that configuration, to accomplish its task it is modular itself and for each hardware detection plugin installed ( such as `lime-hwd-usbradio` ) it execute the respective `clean` method that is supposed to cleanup outdated configuration and the `detect_hardware` method that is supposed to configure the hardware and can put specific `config` sections in `/etc/config/lime` to be read by others lime components if necessary.

==== Wireless
Wireless module is supposed to detect WiFi interfaces and prepare them for usage with Libre-Mesh, to accomplish that task it reads and write to `/etc/config/lime` and `/etc/config/wireless`.

==== Network
Network module is in charge of configuring network interfaces and routing protocols, it is a big task to accomplish in a nifty way to do it is modular too. It offers a tight API to his modules that are called `proto` (such as `lime-proto-bgp`) while they must expose to network module a statefull interface that consists of:

- `configured` flag, it is false by default and setted to true when the `proto` is configured.
- `configure(args)` this method is in charge of configuring the underlying routing protocol, args is an array containing all parameters found in configuration file, parameters have positional meaning.
- `setup_interface(ifname, args)` this function is called once per each networking interface found on the router `ifname` is the linux name of the interface and `args` is an array containing all parameters found in configuration file.
- `apply()` usually just restart the underlying routing protocol to make the new configurations effective.

==== Firewall
If OpenWrt firewall is installed configure it according to Libre-Mesh needs.

==== System
Configure other general and miscellaneous stuff that do not fit well in other modules.

=== Interoperability use-cases
Due to LiMe modular nature this development has many possible application that spread out of boundaries of this internship, in following sections a brief analysis of more common use-cases on which the development has been focused is exposed.

[[meshdistribution]]
==== Mesh network as distribution
In this scenario a BGP backbone is used as transport network while the mesh network is used as ``last mile'' distribution.

image::images/simple_exchange_topology.png[align="center"]

Legend::
- Black routers: routers running LiMe with pure mesh setup.
- Red routers: Guifi.net routers configured as of _{MdHd}_.
- Blue straight lines: Cabled mesh links.
- Blue curvy dashed lines: WiFi mesh links.
- Yellow straight lines: Guifi.net links as of _{MdHd}_.

This use case is someway workable also with the pasts solution but with strong drawbacks:

- Instead of the ``red and black'' router we would need two devices one of the ``red type'' let's call it +R+ and one of the ``black type'' lets call it +B+ connected, this mean a frontier node cost the double on average.
- The +B+ router would announce statically the whole 10.0.0.0/8 to the mesh network and have +R+ as gateway for the entire 10.0.0.0/8 net, this causes packets generated into the mesh directed to nonexistent hosts in that range will flow all across the mesh and even get into the BGP backbone, effectively reducing bandwidth available for legitimate packets.
- In the +R+ router all the subnets used by the mesh network must be statically routed to +B+ router and then written into the BGP daemon configuration to be announced to the rest of the ``red network'', so each time a subnet is added to the the mesh network the +R+ router need to be reconfigured manually, consuming time of some skilled Guifi.net operator.

All those limitations are solved using the software developed during this internship, moreover other more complex and even more common interoperability scenarios gets solved.

==== Mesh network with multiple exchanges
*TODO: Needs further analysis* +
This scenario is very common in high population density zones, small neighborhood community mesh network grow beyond the district boundaries gaining geographical proximity to multiple backbone nodes, as the number of user usually grow too as the network expand having just an exchange point become a bottleneck, in this case having multiple exchange point can improve the access bandwidth to upstream networks.

image::images/multiple_exchanges_topology.png[align="center"]

This scenario in not practically manageable with past technology, and the more exchange point are added the trickier it gets to have a working stable configuration, while with the development done during this internship after BGP peering setup everything works out of the box.

==== Mesh network as transport
*TODO: Needs further analysis* +
The most important technical factor that slowed down LiMe adoption into Guifi.net is that the majority of preexistent network infrastructure is built following the _{MdHd}_ so when someone decide to extend Guifi.net infrastructure need to be compatible with _{MdHd}_, without the development done during this internship the only possible interoperability setup was having the mesh as a <<meshdistribution, leaf network>>, while now it is possible to build Guifi.net backbone with LiMe being compatible both with mesh and BGP networks, it is even possible to use LiMe to fill the gap between isolated BGP network islands.

image::images/mesh_as_transport_topology.png[align="center"]

This will certain encourage LiMe adoption and maybe will finally obsolete _{MdHd}_, giving the possibility to Guifi.net to jump into another phase of horizontal growth with less dependency from manual configuration work, skilled people will have time to work on more interesting and not repetitive tasks, with consequent costs reduction and accessibility for the masses increased.

=== lime-proto-bgp
To accomplish the task of interoperability between Libre-Mesh networks and Guifi.net BGP infrastructure, I had to create a new `proto` for libre-mesh called `lime-proto-bgp`, it is in charge of configuring the LiMe system so it is capable of BGP routing, as back-end it uses BIRD.
While the module is in charge of configuring BGP routing it delegate trought the LiMe modularization pattern to the others `proto` the specific configuration needed to make possible to automatize the interoperation between BGP and the specific `proto`, to accomplish that a new callback has been added to the standard `proto` API:

- `proto.bgp_conf(templateVarsIPv4, templateVarsIPv6)` it is called by the `proto` BGP for each `proto` the user has requested to exchange routes with, this function take as parameters two tables that are both readable to read already defined template variable and writable to eventually define additional template variables to pass back to `proto` BGP and returns a template snippet that is appended to the bird configuration file by `proto` BGP.



== Batman-adv

B.A.T.M.A.N. advanced (often referenced as batman-adv) is an implementation of the B.A.T.M.A.N. routing protocol in form of a linux kernel module operating on layer 2.

=== Network map
[source,bash]
-----------------------
uci del alfred.alfred.disabled
uci commit
/etc/init.d/alfred enable
/etc/init.d/alfred start
-----------------------

== Bird

It's a program which works as a dynamic router in an Internet type network (that is, in a network running either the IPv4 or the IPv6 protocol). It also communicate with the other routers in the Internet to discover the topology of the network which allows him to find optimal (in terms of some metric) rules for forwarding of packets (which are called routing tables) and to adapt themselves to the changing conditions such as outages of network links, building of new connections and so on.


=== Exporting BGP routes to a kernel table

[source,bash]
--------------------------------------
table tobmx;

protocol pipe {
	table master;
	peer table tobmx;
	import all;
	export filter {
		if source = RTS_BGP then accept;
		else reject;
        };
}

protocol kernel
{
	scan time 20;
	table tobmx;
	kernel table 200;
	import all;
	export all;
}
--------------------------------------

=== Importing mesh routes with low preference
Guifi.net BGP routers are form different vendors and often they have different implementation on which route attributes are considered when deciding which path to prefer, after reading documentations from different vendors, seems to me that in eBGP setups (like Guifi.net) the most reliable way to share a route with low preference is to artificially enlarge it's AS path, this technique is called AS-path-prepending and it's common in situation where someone want to share a route but want others routers prefer other paths if there is some path available.
some references:
http://wiki.nil.com/AS-path_prepending_%28technical_details%29
Check #bird 2015/08/19 IRC log for more details


[source,bash]
--------------------------------------
protocol bgp {
        local as 65000;                      # Use a private AS number
        neighbor 198.51.100.130 as 64496;    # Our neighbor ...
        multihop;                            # ... which is connected indirectly
        export filter {                      # We use non-trivial export rules
                if source = RTS_STATIC then { # Export only static routes
                        # Assign our community
                        bgp_community.add((65000,64501));
                        # Artificially increase path length
                        # by advertising local AS number twice
                        if bgp_path ~ [= 65000 =] then
                                bgp_path.prepend(65000);
                        accept;
                }
                reject;
        };
        import all;
        source address 198.51.100.14;   # Use a non-standard source address
}
--------------------------------------

=== Interesting threads

- link:http://bird.network.cz/pipermail/bird-users/2012-February/002822.html[How redistribute routes from kernel table]
- link:http://bird.network.cz/pipermail/bird-users/2013-November/004051.html[Routes in kernel table not being imported]
- link:http://pastebin.ca/2986781[BIRD protocols default preferences]
- link:http://bird.network.cz/?get_doc&f=bird-3.html#ss3.3[BIRD protocol preference option]


== BMX6

=== Route count limitation

BMX6 store distribute routes in a shared structure called ``node description'' for performance reasons the size of this structure is limited and it's not enough to contain the whole Guifi.net BGP routing table, a first approach to resolve this problem was to enable route aggregation in BMX6 ``redistTable'' plug-in, but despite the high CPU usage the size of the table was reduced only by half and that was not enough to fit inside a ``node description'', moreover the high CPU load caused timeouts in communication between BMX6 and Linux kernel causing BMX6 to crash. To solve this problem next BMX6 version (called informally BMX7) node description will be structured like a linked list so the node description can contain a pointer to another structure if just one is not enough to store all the needed informations, the draw back is that this is not compatible with past versions of BMX6 but it doesn't represents a blocking problem because BMX6 users are used too incompatible changes between versions, this solution has been discussed at BattlemeshV8 and we will do further testing at our offices in Barcelona.


=== Importing BGP routes with low bandwidth

[source,bash]
--------------------------------------
config plugin 'table'
        option plugin 'bmx6_table.so'

config redistTable 'fromBird'      
        option redistTable 'fromBird'  
        option table '200'                        
        option bandwidth '100'     
        option all '1'                 
        option sys '12'
--------------------------------------

==== Reducing the performance footprint
Default BMX6 `redistTable` configurations are not suitable to our needs in fact they make the router sloppy and with 100% CPU load every-time, doing some analysis on what was happening I found some causes:

- By default `redistTable` do routes aggregation that is a CPU and memory intensive work.
- It reacts to every single change in the routing table recalculating all aggregations.
- Our routing table is big so calculating the ``aggregated'' version is a long work.
- Our average device have quite limited resources (300-600Mhz MIPS CPU, 32-128MB RAM)

To solve this problem I have disabled route aggregation while enabling routing table event aggregation, with event aggregation it should be even possible to enable route aggregation but further studying it's needed, and the behavior of loop avoidance in case aggregation is enabled need to be studied too.


[source,lua]
---------------------------------------------------------
-- Disable route aggregation
uci:set("bmx6", "fromBird", "aggregatePrefixLen", "128")
-- Aggregate routing tables events by 60s time slots
uci:set("bmx6", "general", "redistTableDelay", "60000") 
---------------------------------------------------------


// Specify the section template avoid "References" being threated as a special section title (see User Guide 5.4.1) that cause an xmllint error
[sect1]
== References

. [[ref:1]] Guifi.net _{MdHd}_ http://es.wiki.guifi.net/wiki/Modelo_h%C3%ADbrido_guifi.net (Castilian)
. [[ref:2]] Quick Mesh Project (qMp) http://qmp.cat/ (Catalan)
. [[ref:3]] QMP manual connection to Guifi.net _{MdHd}_ http://ca.wiki.guifi.net/wiki/Node_frontera_amb_qMp (Catalan)
. [[ref:4]] Guifi.net _{MdHd} {SpNd}s_ http://es.wiki.guifi.net/wiki/Supernodos_h%C3%ADbridos (Castilian)
. [[ref:5]] Guifi.net the largest community network in the world https://en.wikipedia.org/wiki/Community_network

. [[ref:0]] Citation Needed


// Specify the section template avoid "References" being threated as a special section title (see User Guide 5.4.1) that cause an xmllint error
[sect1]
== Glossary

- *AP*: In computer networking, a wireless access point (AP) is a device that allows wireless devices to connect to a wired network using Wi-Fi, or related standards. The AP usually connects to a router (via a wired network) as a standalone device, but it can also be an integral component of the router itself. An AP is differentiated from a hotspot, which is the physical space where the wireless service is provided.

- *AS*: Autonomous System. TODO

- *ASN*: Autonomous System Number. TODO

- *BGP*: Border Gateway Protocol. TODO

- *BIRD*: BIRD Internet Routing Daemon is a network routing software providing implementations of Border Gateway Protocol (BGP), Open Shortest Path First (OSPF) and others routing protocols.

- *Community Network*: TODO

- *Drupal*: TODO

- *eBGP*: External BGP. TODO

- *Firmware*: Firmware is a type of software that usually control low-level components of the device it is usually held in ROM. While this is the general accepted meaning of the term, in the context of embedded routing and in community networks it is common practice to call firmware the software running on the routers, while it is usually flashed like a proper firmware it is really a software providing a full operative system and higher levels tools such as web interface or command line interface.

- *LiMe*: Common abbreviation for Libre-Mesh.

- *Quagga*: Quagga is a network routing software suite providing implementations of Open Shortest Path First (OSPF), Routing Information Protocol (RIP), Border Gateway Protocol (BGP) and IS-IS for Unix-like platforms.

- *Router*: Routers are devices which forward packets between interconnected networks in order to allow hosts not connected directly to the same local area network to communicate with each other.

- *Routing Daemon*: A Routing Daemon is in UNIX terminology a non-interactive program running on background which does the dynamic part of Internet routing, that is it communicates with the other routers, calculates routing tables and sends them to the OS kernel which does the actual packet forwarding.

- *WDS*: A wireless distribution system (WDS) is a system enabling the wireless interconnection of access points in an IEEE 802.11 network. It allows a wireless network to be expanded using multiple access points without the traditional requirement for a wired backbone to link them. The notable advantage of WDS over other solutions is it preserves the MAC addresses of client frames across links between access points.

- *UML*: The Unified Modeling Language (UML) is a general-purpose modeling language in the field of software engineering, which is designed to provide a standard way to visualize the design of a system.

- *WiFi*: TODO

== Appendix A : License
This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. +
To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/. +
Copyright © 2015 {author}.

image::images/CC-by-sa.png["License", align="left", link="http://creativecommons.org/licenses/by-sa/4.0/"]
